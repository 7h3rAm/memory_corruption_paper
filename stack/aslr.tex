\subsection{ASLR}

One of the earliest responses to exploits is Address Space Layout Randomization (ASLR).
Introduced in 2001 in PaX, the goal of ASLR is to make successful exploitation
of a vulnerability more difficult by introducing entropy into addresses
of the stack, heap, functions, and shared objects. If we re-examine
the work we've done so far, we'll notice that we're pretty reliant
on knowing precisely where various things are. For example, to get code
execution we need to both store our shellcode somewhere in the
process' memory space, and know the address it is stored at, so
we can jump to it and redirect execution While we can still
rely on there being a fixed number of bytes from the beginning of
a vulnerable buffer until the stored return address, we'll quickly
notice that some things are moved around, and it's no longer
sufficient to simply overwrite the return pointer with the same constant.

As a demonstration, let's begin with a slightly more complicated, but
still doable, stack-based buffer overflow. This is still without
any protections, so it should be fairly straightforward. This is
\texttt{level00} on the \texttt{fusion} virtual machine from exploit-exercises.com.
This is designed to pick up where protostar left off, and introduce
more advanced concepts, such as exploit mitigations. We'll leave
further vm-specific information for later.

First, the scenario. Following is the important bits of the source 
from exploit-exercises.com:

\lstinputlisting[language=C]{stack/fusion_level00.c}

It's a bit more complicated, but not too bad once we get down to it.
Basically, this program hosts a psuedo-http server. It's not
actually http-compliant at all, but at least forces you to try
and pretend. It listens for connections on a socket, and will
helpfully tell visitors the address of its internal buffer.
After a read from the socket it will parse the input, making
sure it at least sort of looks like an http GET request, then
pass a portion to the \texttt{fix\_path} function. This is where 
things get interesting, as we see that this function
has a 128-byte buffer that it calls a \texttt{strcpy} on! This
is bad. Alright, so we think we've found a vulnerability. Let's 
start experimenting. We can find this program listening on
port 20000 of the virtual machine. using \texttt{fusions}:\texttt{godmode}
to log in (and remembering root's password is also \texttt{godmode}), we
can take advantage of core dumps in reversing this exploit.
First, let's send 200 bytes. Since this has a decent chance of 
overwriting the return pointer, we'll pattern it to help us 
determine memory layout. This can be done with a simple python script
and netcat.

\begin{lstlisting}
buf = []
for i in range(0x41,0x4c):
			buf.append(chr(i)*20)
			print ''.join(buf)
\end{lstlisting}

Using the pre-3.0 python on fusion, we take 20 copies of the first
10 letters each, and append them all together. This gives a nice, 
simple buffer we can just copy/paste:
\begin{lstlisting}
fusion@fusion:~/level00\$ python buf.py 
AAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEFFFFFFFFFFFFFFFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIJJJJJJJJJJJJJJJJJJJJKKKKKKKKKKKKKKKKKKKK
\end{lstlisting}

So, testing is as simple as sending a properly formatted buffer with netcat,
and examining the core dump \texttt{/core}. If this file exists already,
you should delete it with \texttt{rm} before making another.

\begin{lstlisting}
fusion@fusion:~/level00\$ nc localhost 20000
[debug] buffer is at 0xbffff8f8 :-)
GET AAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEFFFFFFFFFFFFFFFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIJJJJJJJJJJJJJJJJJJJJKKKKKKKKKKKKKKKKKKKK HTTP/1.1
fusion@fusion:~/level00\$ sudo gdb -q --core /core
[New LWP 3042]
Core was generated by `/opt/fusion/bin/level00'.
Program terminated with signal 11, Segmentation fault.
#0  0x48484847 in ?? ()
\end{lstlisting}

Excellent! the return pointer happened to be directly on a boundary.
Remembering how the buffer was crafted (increasing order), and the
little-endianness of our intel machine, then we know that
the return address is directly where ``\texttt{GHHH}" is in our buffer.
